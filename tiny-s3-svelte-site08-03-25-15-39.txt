Repository Tree (Shallow):
tiny-s3-svelte-site/
  index.html
  manifest.json
  JenkinsFile
  repotxt.py
  README.md
  LICENSE
  terraform/
    prod.tfvars
    dev.tfvars
    variables.tf
    s3.tf
    provider.tf

==================================================

Repository Compilation - /home/h/git/tiny-s3-svelte-site
Generated on: 08-03-2025 15:39
==================================================

File: index.html
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World</title>
</head>
<body>
    <h1>Hello World</h1>
    <p>This is the index page for the Hello World application.</p>
</body>
</html>
==================================================

File: manifest.json
--------------------------------------------------
{
 "deploy": {
   "dev": true,
   "prod": false
 }
}
==================================================

File: JenkinsFile
--------------------------------------------------
pipeline {
    agent any
    environment {
        TF_VAR_region = "${env.DEPLOY_REGION ?: 'eu-west-2'}" // Default region, override via env vars
    }
    stages {
        stage('Set Environment') {
            steps {
                script {
                    if (env.BRANCH_NAME.startsWith('PR-')) {
                        echo "Running for Pull Request: ${env.BRANCH_NAME}"
                        env.ENV_FILE = 'dev.tfvars'
                        env.DEPLOY_REGION = env.DEPLOY_REGION ?: 'eu-west-2' // Customizable region
                        env.BUCKET_NAME = env.BUCKET_NAME ?: 'my-static-site-bucket-dev' // Generic default
                        env.DEPLOY_ENV = 'dev'
                    } else if (env.BRANCH_NAME == 'main') {
                        echo "Running for Main branch: ${env.BRANCH_NAME}"
                        env.ENV_FILE = 'prod.tfvars'
                        env.DEPLOY_REGION = env.DEPLOY_REGION ?: 'eu-west-2'
                        env.BUCKET_NAME = env.BUCKET_NAME ?: 'my-static-site-bucket-prod'
                        env.DEPLOY_ENV = 'prod'
                    } else {
                        error("Branch ${env.BRANCH_NAME} is not configured for this pipeline!")
                    }
                }
            }
        }
        stage('Checkout Code') {
            steps {
                checkout scm
            }
        }
        stage('Terraform Init') {
            steps {
                dir('terraform') {
                    sh """
                        terraform init \
                        -backend-config="bucket=${env.TF_STATE_BUCKET ?: 'my-tf-state-bucket'}" \
                        -backend-config="region=${env.DEPLOY_REGION}" \
                        -backend-config="key=static-site/${env.DEPLOY_ENV}/terraform.tfstate"
                    """
                }
            }
        }
        stage('Terraform Plan') {
            steps {
                dir('terraform') {
                    sh "terraform plan -var-file=${env.ENV_FILE} -out=tfplan"
                }
            }
        }
        stage('Check Deployment Manifest') {
            steps {
                script {
                    def manifest = readJSON file: 'manifest.json'
                    env.DEPLOY_ENABLED = manifest.deploy[env.DEPLOY_ENV].toString()
                    echo "Deployment enabled for ${env.DEPLOY_ENV}: ${env.DEPLOY_ENABLED}"
                }
            }
        }
        stage('Terraform Apply') {
            when {
                allOf {
                    anyOf {
                        branch 'main'
                        expression { env.BRANCH_NAME.contains('PR-') }
                    }
                    expression { env.DEPLOY_ENABLED == 'true' }
                }
            }
            steps {
                dir('terraform') {
                    sh "terraform apply -auto-approve tfplan"
                }
            }
        }
        stage('Upload index.html') {
            when {
                allOf {
                    anyOf {
                        branch 'main'
                        expression { env.BRANCH_NAME.contains('PR-') }
                    }
                    expression { env.DEPLOY_ENABLED == 'true' }
                }
            }
            steps {
                dir('src') {
                    sh """
                        aws s3 cp index.html s3://${env.BUCKET_NAME}/index.html
                    """
                }
            }
        }
        stage('Tag Release') {
            when {
                allOf {
                    branch 'main'
                    expression { env.DEPLOY_ENABLED == 'true' }
                }
            }
            steps {
                script {
                    def changelog = readFile('changelog.md')
                    def version = changelog.find(/## \[(\d+\.\d+\.\d+)\]/) { match, v -> "v${v}" }
                    if (version) {
                        echo "Tagging release: ${version}"
                        sh """
                            git tag -a ${version} -m "Release ${version}: See changelog for details"
                            git push origin ${version}
                        """
                    } else {
                        echo "No version found in changelog.md to tag."
                    }
                }
            }
        }
    }
    post {
        always {
            echo "Pipeline execution completed for environment using ${env.ENV_FILE}"
        }
    }
}
==================================================

File: repotxt.py
--------------------------------------------------
import os
import git
from pathlib import Path
from datetime import datetime
import fnmatch
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(message)s')

def generate_shallow_file_tree(root_path, out_file, exclude_dirs, exclude_files):
    """Generate a shallow tree diagram, excluding specified directories and files."""
    tree = "Repository Tree (Shallow):\n"
    for root, dirs, files in os.walk(root_path, topdown=True):
        # Exclude unwanted directories
        dirs[:] = [d for d in dirs if d not in exclude_dirs]

        level = root.replace(root_path, "").count(os.sep)
        indent = "  " * level
        dir_name = os.path.basename(root)

        # Only show the directory name if it's not excluded at level 0 or 1
        if level == 0 or (level == 1 and dir_name not in exclude_dirs):
            tree += f"{indent}{dir_name}/\n"

            # If at the top level or in an included directory, list non-excluded files
            if level == 0 or dir_name in ['src', 'terraform', 'public', 'static']:
                for file in files:
                    if not any(fnmatch.fnmatch(file, pattern) for pattern in exclude_files):
                        tree += f"{indent}  {file}\n"

    out_file.write(tree + "\n" + "=" * 50 + "\n\n")

def compile_repo_to_file():
    try:
        # Get the current working directory
        repo_path = os.getcwd()
        folder_name = os.path.basename(repo_path)
        current_time = datetime.now().strftime("%d-%m-%y-%H-%M")
        output_file = f"{folder_name}{current_time}.txt"

        # Initialize git repo object
        repo = git.Repo(repo_path)
        logging.info(f"Processing repository at: {repo_path}")

        # Get gitignore patterns
        gitignore_patterns = []
        gitignore_file = os.path.join(repo_path, '.gitignore')
        if os.path.exists(gitignore_file):
            with open(gitignore_file, 'r') as f:
                gitignore_patterns = [
                    line.strip()
                    for line in f
                    if line.strip() and not line.startswith('#')
                ]
            logging.info(f"Found .gitignore patterns: {gitignore_patterns}")

        # Directories to exclude
        exclude_dirs = ['.git', 'node_modules', '.svelte-kit', 'build']

        # Files to exclude (patterns)
        exclude_files = [
            '*.lock',
            'package-lock.json',
            '*.txt',
            'repoToText.py',
        ]

        # Combine .gitignore patterns with our explicit exclude_files
        # if you want them all treated equally:
        all_exclude_patterns = gitignore_patterns + exclude_files

        with open(output_file, 'w', encoding='utf-8') as out_file:
            # Add shallow tree diagram
            generate_shallow_file_tree(repo_path, out_file, exclude_dirs, exclude_files)

            # Write header with timestamp
            out_file.write(f"Repository Compilation - {repo_path}\n")
            out_file.write(f"Generated on: {datetime.now().strftime('%d-%m-%Y %H:%M')}\n")
            out_file.write("=" * 50 + "\n\n")

            # Walk through all files in the repo
            for root, dirs, files in os.walk(repo_path):
                # Skip excluded directories
                dirs[:] = [d for d in dirs if d not in exclude_dirs]
                if '.git' in root:
                    continue

                for file_name in files:
                    file_path = os.path.join(root, file_name)
                    relative_path = os.path.relpath(file_path, repo_path)
                    logging.info(f"Processing: {relative_path}")

                    # Determine if the file should be excluded
                    if any(
                        fnmatch.fnmatch(relative_path, pattern) or
                        fnmatch.fnmatch(file_name, pattern)
                        for pattern in all_exclude_patterns
                    ):
                        logging.info(f"Skipping ignored file: {relative_path}")
                        continue

                    # Write file information
                    out_file.write(f"File: {relative_path}\n")
                    out_file.write("-" * 50 + "\n")

                    # Try to read and write file contents with fallback encoding
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            out_file.write(content)
                    except UnicodeDecodeError:
                        out_file.write("[Binary file or could not decode with UTF-8]\n")
                    except IOError as e:
                        out_file.write(f"[IOError: Could not read file - {str(e)}]\n")
                    except Exception as e:
                        out_file.write(f"[Error: {str(e)}]\n")

                    out_file.write("\n" + "=" * 50 + "\n\n")

        logging.info(f"Repository contents compiled to {output_file}")

    except git.exc.InvalidGitRepositoryError:
        logging.error("Error: Current directory is not a git repository")
    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    compile_repo_to_file()

==================================================

File: README.md
--------------------------------------------------
# Static Site Deployment Template

This repository provides a template for deploying a static website to AWS S3 using Terraform and a Jenkins pipeline. It’s designed to be modular and customizable for dev and prod environments.

## Prerequisites
- **AWS Account** with credentials configured.
- **Jenkins Server** with AWS CLI and Terraform installed.
- **Git** for version control.

## Repository Structure
- `Jenkinsfile`: CI/CD pipeline configuration.
- `manifest.json`: Controls deployment for dev/prod.
- `terraform/`: Terraform configurations for S3 hosting.
- `src/`: Static site files (e.g., `index.html`).

## Setup Instructions
1. **Clone the Repository:**
   ```bash
   git clone <your-repo-url>
   cd static-site-template
==================================================

File: LICENSE
--------------------------------------------------
MIT License

Copyright (c) 2025 [Harrison-Wallace]

Permission is hereby granted, free of charge, to any person obtaining a copy...
==================================================

File: terraform/prod.tfvars
--------------------------------------------------
bucket_name = "my-static-site-bucket-prod"
environment = "prod"
==================================================

File: terraform/dev.tfvars
--------------------------------------------------
bucket_name = "your-unique-bucket-name"
environment = "dev" # or "prod"
==================================================

File: terraform/variables.tf
--------------------------------------------------
variable "bucket_name" {
  description = "Name of the S3 bucket (must be globally unique)"
  type        = string
}

variable "environment" {
  description = "Environment (dev/prod)"
  type        = string
}

variable "region" {
  description = "AWS region for deployment"
  type        = string
  default     = "eu-west-2"
}
==================================================

File: terraform/s3.tf
--------------------------------------------------
resource "aws_s3_bucket" "my_static_bucket" {
  bucket        = var.bucket_name
  force_destroy = true
  tags = {
    Name        = var.bucket_name
    Environment = var.environment
  }
}

resource "aws_s3_bucket_ownership_controls" "my_static_bucket_ownership" {
  bucket = aws_s3_bucket.my_static_bucket.id
  rule {
    object_ownership = "BucketOwnerEnforced"
  }
}

resource "aws_s3_bucket_public_access_block" "my_static_bucket_public_access" {
  bucket                  = aws_s3_bucket.my_static_bucket.id
  block_public_acls       = false
  block_public_policy     = false
  ignore_public_acls      = false
  restrict_public_buckets = false
}

resource "aws_s3_bucket_website_configuration" "my_static_bucket_website" {
  bucket = aws_s3_bucket.my_static_bucket.id
  index_document {
    suffix = "index.html"
  }
  error_document {
    key = "404.html"
  }
}

resource "aws_s3_bucket_policy" "public_read" {
  bucket = aws_s3_bucket.my_static_bucket.id
  policy = jsonencode({
    Version   = "2012-10-17"
    Statement = [
      {
        Sid       = "PublicReadGetObject"
        Effect    = "Allow"
        Principal = "*"
        Action    = "s3:GetObject"
        Resource  = "${aws_s3_bucket.my_static_bucket.arn}/*"
      }
    ]
  })
  depends_on = [aws_s3_bucket_public_access_block.my_static_bucket_public_access]
}

output "url" {
  value = "http://${aws_s3_bucket_website_configuration.my_static_bucket_website.website_endpoint}"
}
==================================================

File: terraform/provider.tf
--------------------------------------------------
provider "aws" {
  region = var.region # Default set in variables.tf
}

terraform {
  backend "s3" {
    bucket         = "my-tf-state-bucket" # Update this
    region         = "eu-west-2"          # Update this
    encrypt        = true
  }
}
==================================================

